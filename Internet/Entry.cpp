#include "Client.hpp"

int
main(
	void
)
{
	//
	// Create and zero out the NTP packet.
	// Set the leap indicator to LI_NO_WARNING. The server will determine its own leap indicator and send it back.
	//
	NTP_3_HEADER Packet = { 0 };
	Packet.Attributes = NTP_CALCULATE_ATTRIBUTES(LI_NO_WARNING, VN_3, MODE_CLIENT);

	//
	// Configure the server address.
	// For debugging purpose, we can use local IP (127.0.0.1) and port 12345.
	//
	sockaddr_in ServerAddress = { 0 };
	ServerAddress.sin_family = AF_INET;
	ServerAddress.sin_port = Util::SwitchEndianness16(NTP_PORT);

	if (inet_pton(AF_INET, Client::GetIp("time.google.com").c_str(), &ServerAddress.sin_addr) <= 0)
	{
		std::cerr << "inet_pton failed" << std::endl;
		return 1;
	}

	//
	// Create the UDP socket.
	//
	std::int32_t SockFd = socket(AF_INET, SOCK_DGRAM, 0);

	if (SockFd < 0)
	{
		std::cerr << "Socket creation failed" << std::endl;
		return 1;
	}
	
	//
	// Set the poll interval.
	// Essentially a hint from the client how frequently it's willing to query the server for time.
	//
	Packet.PollInterval = NTP_CALCULATE_POLL_INTERVAL(64000);
	std::cout << std::hex << "PollInterval " << static_cast<double>(Packet.PollInterval) << std::endl;

	//
	// Set the precision.
	// The server will set its own precision in the response.
	//
	Packet.Precision = NTP_CALCULATE_PRECISION(Util::GetFrequency());
	std::cout << std::hex << "precision " << static_cast<double>(Packet.Precision) << std::endl;

	//
	// Generate a random transmit timestamp and save it.
	// The server will copy that timestamp to the originate timestamp.
	// The client shall verify the originate timestamp of the returned packet with this timestamp.
	// Source: https://www.ietf.org/archive/id/draft-ietf-ntp-data-minimization-04.txt
	//
	NTP_TIMESTAMP RandomTimestamp = NTPv3::GenerateRandomTimestamp();
	Packet.TransmitTimestamp.Full = RandomTimestamp.Full;

	//
	// Send the packet.
	//
	ssize_t Sent = sendto(SockFd, &Packet, sizeof(NTP_3_HEADER), 0, reinterpret_cast<sockaddr*>(&ServerAddress), sizeof(ServerAddress));

	if (Sent < 0)
	{
		std::cerr << "sendto failed" << std::endl;
		close(SockFd);
		return 1;
	}

	//
	// Receive the NTP response packet.
	//
	sockaddr_in ReceiveAddress{};
	socklen_t AddressLength = sizeof(ReceiveAddress);
	ssize_t Received = recvfrom(SockFd, &Packet, sizeof(NTP_3_HEADER), 0, reinterpret_cast<sockaddr*>(&ReceiveAddress), &AddressLength);

	if (Received < 0)
	{
		std::cerr << "recvfrom failed" << std::endl;
		close(SockFd);
		return 1;
	}

	//
	// Verify the originate timestamp with the first transmit timestamp generated by the client.
	//
	if (RandomTimestamp.Full != Packet.OriginateTimestamp.Full)
	{
		std::cerr << "Verification failed" << std::endl;
		close(SockFd);
		return 1;
	}

	//
	// Extract timestamps from the received packet.
	// Timestamps are in big endian format, we have to convert them to little endian format first.
	//
	std::time_t TransmitTimestamp = Util::SwitchEndianness32(Packet.TransmitTimestamp.High) - NTP_TIMESTAMP_DELTA;
	std::tm* gmtTime = std::gmtime(&TransmitTimestamp);
	std::cout << "TransmitTimestamp (UTC): " << std::asctime(gmtTime) << std::endl;

	std::cout << std::hex << Packet.OriginateTimestamp.Full << std::endl;
	std::cout << std::hex << Packet.TransmitTimestamp.Full << std::endl;

	if (Packet.OriginateTimestamp.Full == RandomTimestamp.Full)
	{
		std::cout << "orig" << std::endl;
	}

	std::cout << std::hex << "precision " << static_cast<double>(Packet.Precision) << std::endl;
	std::cout << std::hex << "PollInterval " << static_cast<double>(Packet.PollInterval) << std::endl;
	std::cout << std::dec << "RootDispersion " << static_cast<double>(Packet.RootDispersion) / (1 << 16) << std::endl;
	char referenceClockId[5] = { 0 };  // 4 chars + null terminator
	std::memcpy(referenceClockId, &Packet.ReferenceClockIdentifier, 4);
	std::cout << "ReferenceClockIdentifier: " << referenceClockId << std::endl;

	close(SockFd);
	return 0;
}